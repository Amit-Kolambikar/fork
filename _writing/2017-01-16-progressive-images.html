---
title: Responsive, Progressive Images Made Easy
date: 2017-01-16
hero_image: writing/building-the-image-grid-from-google-photos-hero.png
hero_style: large
featured_image: writing/building-the-image-grid-from-google-photos.png
---

<p>Every year or so, I rewrite my personal website from scratch. The design is a signal of how I'm feeling or what I'm thinking about; the implementation is based on new and ever-changing constraints.  My latest redesign, launched this past fall, focused on a newly present desire to host photography.  I had photos from my recent travel, but no where to put them.</p>

<p>As I often do when working on a new design, I engineer things obsessively. In this version, I was committed to implement best practices when it came to loading images.  That meant <strong>responsive</strong> (loading the right size image on different size devices), <strong>progressive</strong> (displaying a meaningful placeholder while the image loads), and <strong>easy to manage</strong> (not requiring lots of manual work to add new images or change existing ones). Achieving all three was really fun, and required building up some new tools to make working with images easy. Here's how I did it.</p>

<h2>Responsive Images</h2>

<p>Making images responsive is the most important feature of a website that loads quickly, is respectful of users' data plans, and looks great on all devices. With my travel photos, it was really important to me that visitors on large-screened devices got full, high resolution images. But, on phones and tablets, loading large images is expensive and can take a long time.</p>

<p>The solution is to generate multiple different sizes of image, and load the appropriate image based on the screen size. To achieve this, I need a snippet of HTML to represent where the image will be, and some JavaScript to load the correct image. The basic HTML looks like this:</p>

{% highlight html %}
<figure class="progressive-image"
        data-small="/img/res/400/path/to/src"
        data-medium="/img/res/800/path/to/src"
        data-large="/img/res/1600/path/to/src"
        data-raw="/img/res/raw/path/to/src">
</figure>
{% endhighlight %}

<p>I provide four different sizes: small (400p), medium (800p), large (1600p), and the raw (often 3000p or more). Then, in Javascript, I wrote a <code>ProgressiveImage</code> class that, when initialized with a <code>&lt;figure&gt;&lt;/figure&gt;</code>, loads the appropriately sized image.  The constructor is simple:</p>

{% highlight js %}
function ProgressiveImage(figure) {
  this.figure = figure;
  this.lastWindowWidth = window.innerWidth;
  this.load();

  return this;
}
{% endhighlight%}

<p>I capture the passed in <code>&lt;figure&gt;&lt;/figure&gt;</code> element, and measure the current window width.  Then, all that's left is to call the <code>load()</code> function, which inserts the full size image into the DOM:</p>

{% highlight js %}
/**
 * Load the full image element into the DOM.
 */
ProgressiveImage.prototype.load = function () {
  // Create a new image element, and insert it into the DOM.
  var fullImage = new Image();
  fullImage.src = this.figure.dataset[this.getSize()];
  fullImage.className = 'full';
  fullImage.onload = function () {
    this.figure.className += ' loaded';
  }.bind(this);

  this.figure.appendChild(fullImage);
};
{% endhighlight %}

<p>This creates a new image tag, inserts it into the figure, and adds the class <code>loaded</code> to the figure when it has been fully loaded. The only interesting question here is how to determine what the source URL should be, which I've factored out into a separate <code>getSize()</code> function:</p>

{% highlight js %}
/**
 * Choose the size of image to load based on the window width.
 */
ProgressiveImage.prototype.getSize = function () {
  var sizes = ['small', 'medium', 'large'];
  var sizeIndex;
  if (this.lastWindowWidth < 768) {
    sizeIndex = 0; // small
  } else if (this.lastWindowWidth < 1440) {
    sizeIndex = 1; // medium
  } else {
    sizeIndex = 2; // large;
  }

  // Retina devices should have larger pixel densities.
  if (window.devicePixelRatio > 1 && sizeIndex < 2) {
    sizeIndex += 1;
  }

  return sizes[sizeIndex];
};
{% endhighlight %}

<p>The logic works like this: First, assign a size based on the window width: small for screens narrower than 768px, medium for those between 768px and 1440px, and large for screens wider than 1440px. Then, if if the device is a retina device (with a device pixel to digital pixel ratio greater than 1, bump up the image a size.</p>

<p>Note that this logic just chooses between one of three sizes, and doesn't account for the size of the image on the screen. (Small images in grids will get the same result as huge full-bleed images.) In my <a href="#TODO">final implementation</a>, I allow for overrides to force a particular size, a solution that works great for small images in grids.</p>

<p>With those three functions, and a bit of markup, I added responsive images to my site.  Next up, a few tweaks to my responsive setup will give users a meaningful placeholder while the full image loads.</p>

<h2>Progressive Images</h2>
<p>Adding an intelligent placeholder for your image while its loading provides a better user experience for users on slow connections, and can also deliver performance improvements across the board.</p>

<p>We've all been there: loading a long article with lots of text and images, and when you're half way done reading the article, images above start popping into place, having finally loaded and been inserted into the DOM. Without any placeholder taking their place, loading images into the page too late can cause the page to jump.  This jump is a result of the browser recomputing layouts after elements are inserted into the DOM. With a smart placeholder for your image, you'll avoid your page jumping around as the page loads, and you'll see better page performance having avoid unenessary layouts.</p>

